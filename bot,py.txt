# -*- coding: utf-8 -*-
# ShieldX Bot v3.1 ‚Äî Hybrid (Always-on NSFW, auto-clean, spam-mute, multi-lang UI)
# Requirements: pyrogram, flask, python-dotenv, opencv-python (optional), numpy (optional), pillow (optional)

import asyncio
import os
import threading
import time
import tempfile
import shutil
from datetime import datetime, timedelta
from flask import Flask
from pyrogram import Client, filters, types
from pyrogram.errors import RPCError
from pyrogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from dotenv import load_dotenv

# Optional image libs for local NSFW heuristic
try:
    import cv2
    import numpy as np
    from PIL import Image
except Exception:
    cv2 = None
    np = None
    Image = None

# === Load .env Variables ===
load_dotenv()
API_ID = int(os.getenv("API_ID", 0))
API_HASH = os.getenv("API_HASH", "")
BOT_TOKEN = os.getenv("BOT_TOKEN", "")
OWNER_ID = int(os.getenv("OWNER_ID", 0))
PORT = int(os.getenv("PORT", 8080))
DEFAULT_LANG = os.getenv("LANG", "en")  # default bot language

# === Flask App for KeepAlive / Health ===
app = Flask(__name__)

@app.route("/")
def home():
    return "üõ°Ô∏è ShieldX Active ‚Äî running 24√ó7."

@app.route("/healthz")
def healthz():
    return "ok"

def keep_alive_sync():
    # Bind to PORT from env (Render / hosts expect PORT)
    app.run(host="0.0.0.0", port=PORT)

# === Text Constants (multi-language support store) ===
LANG_STRINGS = {
    "en": {
        "start_dm_text": (
            "üõ°Ô∏è **Welcome to ShieldX Protection!**\n\n"
            "I‚Äôm your 24√ó7 automated guard that keeps your Telegram groups clean and secure.\n\n"
            "üßπ What I do:\n"
            "‚Ä¢ Auto-clean spam & media floods\n"
            "‚Ä¢ Detect & delete NSFW content\n"
            "‚Ä¢ Keep your community safe without downtime\n\n"
            "üöÄ Add me to your group to activate real-time protection."
        ),
        "start_group_text": "üõ°Ô∏è ShieldX is now active in this group! Admins: use /help.",
        "help_dm": (
            "‚ú® **ShieldX ‚Äî Control Center**\n\n"
            "üßπ **Auto-Clean:**\n"
            "‚Ä¢ /clean on ‚Äî enable auto-clean (default: 30m)\n"
            "‚Ä¢ /clean_custom <time> ‚Äî set custom clean time (e.g., 20m, 1h)\n            "
            "‚Ä¢ /clean off ‚Äî disable auto-clean\n"
            "‚Ä¢ /cleanstatus ‚Äî show current clean status\n"
            "‚Ä¢ /cleanall ‚Äî delete recent media (last 24h)\n\n"
            "üö´ **NSFW Protection:**\n"
            "‚Ä¢ Always active ‚Äî images/videos scanned and deleted instantly if NSFW.\n\n"
            "‚öôÔ∏è **Utility:**\n"
            "‚Ä¢ /status ‚Äî view live protection state\n"
            "‚Ä¢ /ping ‚Äî check response & uptime\n"
            "‚Ä¢ /lang <code> ‚Äî change UI language for this chat\n\n"
            "üïí Default clean interval: 30 minutes"
        ),
        "help_group": "üì© Check your DM for ShieldX‚Äôs full command list.",
        "clean_on": "‚úÖ Auto-clean enabled ‚Äî media will be removed every 30 minutes.",
        "clean_custom": "‚úÖ Auto-clean enabled ‚Äî media will be removed every {t}.",
        "clean_off": "üõë Auto-clean disabled.",
        "cleanall_start": "üßπ Starting safe media delete for last {t}... This may take a while.",
        "cleanall_done": "‚úÖ Media delete complete ‚Äî removed {n} media items from last {t}.",
        "status_text": "üßπ Auto-clean: {on} | Interval: {t}",
        "ping_text": "ü©µ ShieldX Online!\n‚ö° {ms}ms | Uptime: {uptime}",
        "nsfw_deleted": "‚ö†Ô∏è NSFW content detected and deleted. Please follow group rules.",
        "nsfw_muted": "üö´ User muted for repeated NSFW spam.",
        "lang_changed": "üåê Language for this chat changed to: {lang}",
        "no_permission": "‚ùå You must be an admin or the owner to use this command.",
        "unknown_lang": "‚ö†Ô∏è Unknown language code.",
        "status_overview": "üß≠ ShieldX status:\nAuto-clean: {clean}\nNSFW: always ON\nLanguage: {lang}"
    },
    "hi": {
        "start_dm_text": "üõ°Ô∏è ShieldX ‡§Æ‡•á‡§Ç ‡§Ü‡§™‡§ï‡§æ ‡§∏‡•ç‡§µ‡§æ‡§ó‡§§ ‡§π‡•à! ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•á ‡§∏‡§Æ‡•Ç‡§π ‡§ï‡•ã 24√ó7 ‡§∏‡•Å‡§∞‡§ï‡•ç‡§∑‡§ø‡§§ ‡§∞‡§ñ‡§§‡§æ ‡§π‡•Ç‡§Å‡•§",
        "start_group_text": "üõ°Ô∏è ShieldX ‡§Ö‡§¨ ‡§á‡§∏ ‡§∏‡§Æ‡•Ç‡§π ‡§Æ‡•á‡§Ç ‡§∏‡§ï‡•ç‡§∞‡§ø‡§Ø ‡§π‡•à! ‡§è‡§°‡§Æ‡§ø‡§® /help ‡§¶‡•á‡§ñ‡•á‡§Ç‡•§",
        "help_dm": "‚ú® ShieldX ‚Äî ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§∏‡•Ç‡§ö‡•Ä (‡§∏‡§Ç‡§ï‡•ç‡§∑‡•á‡§™):\n/clean on, /clean_custom, /clean off, /cleanstatus, /ping, /lang <code>",
        "help_group": "üì© ‡§™‡•Ç‡§∞‡•ç‡§£ ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§∏‡•Ç‡§ö‡•Ä ‡§ï‡•á ‡§≤‡§ø‡§è DM ‡§¶‡•á‡§ñ‡•á‡§Ç‡•§",
        "clean_on": "‚úÖ ‡§ë‡§ü‡•ã-‡§ï‡•ç‡§≤‡•Ä‡§® ‡§∏‡§ï‡•ç‡§∑‡§Æ ‚Äî ‡§™‡•ç‡§∞‡§§‡•ç‡§Ø‡•á‡§ï 30 ‡§Æ‡§ø‡§®‡§ü ‡§Æ‡•á‡§Ç ‡§Æ‡•Ä‡§°‡§ø‡§Ø‡§æ ‡§π‡§ü‡§æ‡§Ø‡§æ ‡§ú‡§æ‡§è‡§ó‡§æ‡•§",
        "clean_custom": "‚úÖ ‡§ë‡§ü‡•ã-‡§ï‡•ç‡§≤‡•Ä‡§® ‡§∏‡§ï‡•ç‡§∑‡§Æ ‚Äî ‡§Æ‡•Ä‡§°‡§ø‡§Ø‡§æ ‡§π‡§ü‡§æ‡§Ø‡§æ ‡§ú‡§æ‡§è‡§ó‡§æ ‡§π‡§∞ {t}‡•§",
        "clean_off": "üõë ‡§ë‡§ü‡•ã-‡§ï‡•ç‡§≤‡•Ä‡§® ‡§Ö‡§ï‡•ç‡§∑‡§Æ‡•§",
        "cleanall_start": "üßπ ‡§™‡§ø‡§õ‡§≤‡•á {t} ‡§ï‡•á ‡§Æ‡•Ä‡§°‡§ø‡§Ø‡§æ ‡§ï‡•Ä ‡§∏‡•Å‡§∞‡§ï‡•ç‡§∑‡§ø‡§§ ‡§π‡§ü‡§æ‡§à ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞ ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Å...",
        "cleanall_done": "‚úÖ ‡§Æ‡•Ä‡§°‡§ø‡§Ø‡§æ ‡§π‡§ü‡§æ‡§®‡§æ ‡§™‡•Ç‡§∞‡§æ ‚Äî ‡§π‡§ü‡§æ‡§è ‡§ó‡§è {n} ‡§Ü‡§á‡§ü‡§Æ‡•§",
        "status_text": "üßπ Auto-clean: {on} | Interval: {t}",
        "ping_text": "ü©µ ShieldX ‡§ë‡§®‡§≤‡§æ‡§á‡§®!\n‚ö° {ms}ms | Uptime: {uptime}",
        "nsfw_deleted": "‚ö†Ô∏è NSFW ‡§ï‡§Ç‡§ü‡•á‡§Ç‡§ü ‡§π‡§ü‡§æ‡§Ø‡§æ ‡§ó‡§Ø‡§æ‡•§ ‡§®‡§ø‡§Ø‡§Æ‡•ã‡§Ç ‡§ï‡§æ ‡§™‡§æ‡§≤‡§® ‡§ï‡§∞‡•á‡§Ç‡•§",
        "nsfw_muted": "üö´ ‡§Ø‡•Ç‡§ú‡§º‡§∞ ‡§ï‡•ã NSFW ‡§∏‡•ç‡§™‡•à‡§Æ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ï‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ‡•§",
        "lang_changed": "üåê ‡§á‡§∏ ‡§ö‡•à‡§ü ‡§ï‡•Ä ‡§≠‡§æ‡§∑‡§æ ‡§¨‡§¶‡§≤ ‡§¶‡•Ä ‡§ó‡§à: {lang}",
        "no_permission": "‚ùå ‡§á‡§∏ ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Ü‡§™‡§ï‡•ã ‡§è‡§°‡§Æ‡§ø‡§® ‡§Ø‡§æ ‡§ì‡§®‡§∞ ‡§π‡•ã‡§®‡§æ ‡§ö‡§æ‡§π‡§ø‡§è‡•§",
        "unknown_lang": "‚ö†Ô∏è ‡§Ö‡§ú‡•ç‡§û‡§æ‡§§ ‡§≠‡§æ‡§∑‡§æ ‡§ï‡•ã‡§°‡•§",
        "status_overview": "üß≠ ShieldX ‡§∏‡•ç‡§•‡§ø‡§§‡§ø:\nAuto-clean: {clean}\nNSFW: ‡§π‡§Æ‡•á‡§∂‡§æ ON\nLanguage: {lang}"
    }
}

# Per-chat language (defaults to DEFAULT_LANG)
chat_lang = {}  # chat_id -> lang_code

def t(chat_id: int, key: str, **kwargs) -> str:
    lang = chat_lang.get(chat_id, DEFAULT_LANG)
    strings = LANG_STRINGS.get(lang, LANG_STRINGS["en"])
    text = strings.get(key, LANG_STRINGS["en"].get(key, ""))
    try:
        return text.format(**kwargs)
    except Exception:
        return text

# === Pyrogram Client ===
bot = Client("ShieldX", api_id=API_ID, api_hash=API_HASH, bot_token=BOT_TOKEN)

# === State stores ===
clean_intervals = {}   # chat_id: seconds
clean_tasks = {}       # chat_id: asyncio.Task

# Keep user nsfw timestamps for spam detection (sliding window)
user_nsfw_log = {}  # chat_id -> { user_id: [timestamps] }

# === Module check (startup log) ===
def log_module_status():
    cv2_ok = "OK" if cv2 is not None else "MISSING"
    pil_ok = "OK" if Image is not None else "MISSING"
    np_ok = "OK" if np is not None else "MISSING"
    print(f"üß† NSFW modules check ‚Üí cv2: {cv2_ok}, PIL: {pil_ok}, numpy: {np_ok}")
    if cv2 is None or Image is None or np is None:
        print("‚ö†Ô∏è NSFW detection will run in fallback mode if modules are missing (no crash).")

# --------------------------
# Helper: allow owner OR bot OR admin
# --------------------------
async def is_admin_or_owner(client, chat_id: int, user_id: int) -> bool:
    try:
        if user_id == OWNER_ID:
            return True
        me = await client.get_me()
        if me and getattr(me, "id", None) == user_id:
            return True
        member = await client.get_chat_member(chat_id, user_id)
        if getattr(member, "status", None) in ("administrator", "creator"):
            return True
    except Exception:
        pass
    return False

# --------------------------
# Local NSFW heuristic (skin ratio)
# --------------------------
def is_nsfw_local(image_path: str, skin_ratio_threshold: float = 0.30) -> bool:
    if cv2 is None or np is None:
        return False
    try:
        img = cv2.imdecode(np.fromfile(image_path, dtype=np.uint8), cv2.IMREAD_COLOR)
        if img is None:
            return False
        h, w = img.shape[:2]
        scale = 600.0 / max(h, w) if max(h, w) > 600 else 1.0
        if scale != 1.0:
            img = cv2.resize(img, (int(w * scale), int(h * scale)))
        hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
        lower1 = np.array([0, 10, 60], dtype=np.uint8)
        upper1 = np.array([20, 150, 255], dtype=np.uint8)
        lower2 = np.array([160, 10, 60], dtype=np.uint8)
        upper2 = np.array([179, 150, 255], dtype=np.uint8)
        mask = cv2.bitwise_or(cv2.inRange(hsv, lower1, upper1), cv2.inRange(hsv, lower2, upper2))
        skin_pixels = int(cv2.countNonZero(mask))
        total_pixels = img.shape[0] * img.shape[1]
        ratio = skin_pixels / float(total_pixels) if total_pixels > 0 else 0.0
        return ratio >= skin_ratio_threshold
    except Exception as e:
        print("is_nsfw_local error:", e)
        return False

# --------------------------
# Periodic cleaner task per chat (auto-clean) - BATCH-WISE
# --------------------------
async def clean_media_periodically(client, chat_id: int, interval: int):
    while True:
        try:
            deleted = 0
            batch = []
            async for msg in client.get_chat_history(chat_id, limit=500):
                if msg.media:
                    batch.append(msg.message_id)
                    if len(batch) >= 20:
                        try:
                            await client.delete_messages(chat_id, batch)
                            deleted += len(batch)
                        except Exception:
                            for mid in batch:
                                try:
                                    await client.delete_messages(chat_id, mid)
                                except:
                                    pass
                        batch.clear()
                        await asyncio.sleep(2)
            if batch:
                try:
                    await client.delete_messages(chat_id, batch)
                    deleted += len(batch)
                except Exception:
                    for mid in batch:
                        try:
                            await client.delete_messages(chat_id, mid)
                        except:
                            pass
            if deleted:
                print(f"[AUTO CLEAN] Deleted {deleted} media in chat {chat_id}")
            await asyncio.sleep(interval)
        except RPCError:
            await asyncio.sleep(10)
        except Exception as e:
            print("clean_media_periodically error:", e)
            await asyncio.sleep(10)

# --------------------------
# Handlers: start/help/ping/lang
# --------------------------
@bot.on_message(filters.command("start"))
async def start_cmd(client, message):
    if message.chat.type == "private":
        buttons = [
            [InlineKeyboardButton("‚ûï Add to Group", url=f"https://t.me/{(await client.get_me()).username}?startgroup=true"),
             InlineKeyboardButton("üí¨ Support", url="https://t.me/ShieldXSupport")]
        ]
        await message.reply_text(t(message.chat.id, "start_dm_text"), reply_markup=InlineKeyboardMarkup(buttons), disable_web_page_preview=True)
    else:
        await message.reply_text(t(message.chat.id, "start_group_text"), disable_web_page_preview=True)

@bot.on_message(filters.command("help"))
async def help_cmd(client, message):
    if message.chat.type == "private":
        await message.reply_text(t(message.chat.id, "help_dm"), disable_web_page_preview=True)
    else:
        await message.reply_text(t(message.chat.id, "help_group"), disable_web_page_preview=True)

start_time = time.time()

@bot.on_message(filters.command("ping"))
async def ping_cmd(client, message):
    start = time.time()
    try:
        m = await message.reply_text("üèì Pinging...")
        ms = int((time.time() - start) * 1000)
        uptime = str(datetime.utcnow() - datetime.utcfromtimestamp(start_time)).split(".")[0]
        await m.edit_text(t(message.chat.id, "ping_text", ms=ms, uptime=uptime))
    except Exception:
        uptime = str(datetime.utcnow() - datetime.utcfromtimestamp(start_time)).split(".")[0]
        await message.reply_text(t(message.chat.id, "ping_text", ms=0, uptime=uptime))

@bot.on_message(filters.command("lang"))
async def lang_cmd(client, message):
    parts = message.text.split(maxsplit=1)
    if len(parts) < 2:
        await message.reply_text("Usage: /lang <code> (e.g. en, hi, ru)")
        return
    code = parts[1].strip().lower()
    if code not in LANG_STRINGS:
        await message.reply_text(t(message.chat.id, "unknown_lang"))
        return
    chat_lang[message.chat.id] = code
    await message.reply_text(t(message.chat.id, "lang_changed", lang=code))

@bot.on_message(filters.command("status"))
async def status_cmd(client, message):
    chat_id = message.chat.id
    on = "ON" if chat_id in clean_tasks else "OFF"
    interval = clean_intervals.get(chat_id, 0)
    t_str = f"{interval//60}m" if interval else "‚Äî"
    lang = chat_lang.get(chat_id, DEFAULT_LANG)
    await message.reply_text(t(chat_id, "status_overview", clean=on, lang=lang))

# --------------------------
# CLEAN commands: /clean on, /clean_custom, /clean off, /cleanstatus, /cleanall
# --------------------------
@bot.on_message(filters.command(["clean", "clean_on"], prefixes=["/", "!", "."]))
async def clean_on_cmd(client, msg):
    try:
        user_id = msg.from_user.id if msg.from_user else None
        if not user_id or not await is_admin_or_owner(client, msg.chat.id, user_id):
            await msg.reply_text(t(msg.chat.id, "no_permission"))
            return
    except:
        return

    chat_id = msg.chat.id
    interval = 30 * 60  # 30 minutes default
    if chat_id in clean_tasks:
        try:
            clean_tasks[chat_id].cancel()
        except:
            pass
    task = asyncio.create_task(clean_media_periodically(client, chat_id, interval))
    clean_tasks[chat_id] = task
    clean_intervals[chat_id] = interval
    await msg.reply_text(t(chat_id, "clean_on"))

@bot.on_message(filters.command("clean_custom"))
async def clean_custom_cmd(client, msg):
    try:
        user_id = msg.from_user.id if msg.from_user else None
        if not user_id or not await is_admin_or_owner(client, msg.chat.id, user_id):
            await msg.reply_text(t(msg.chat.id, "no_permission"))
            return
    except:
        return

    parts = msg.text.split(maxsplit=1)
    if len(parts) < 2:
        await msg.reply_text("Usage: /clean_custom <time> e.g., /clean_custom 20m", quote=True)
        return
    t = parts[1].strip().lower()
    seconds = 0
    try:
        if t.endswith("m"):
            minutes = int(t[:-1])
            if minutes < 1 or minutes > 1440:
                await msg.reply_text("‚ö†Ô∏è /clean_custom supports 1m to 24h only.", quote=True)
                return
            seconds = minutes * 60
        elif t.endswith("h"):
            hours = int(t[:-1])
            if hours < 1 or hours > 24:
                await msg.reply_text("‚ö†Ô∏è /clean_custom supports 1h to 24h only.", quote=True)
                return
            seconds = hours * 3600
        else:
            await msg.reply_text("Invalid format! Use like 20m or 1h.", quote=True)
            return
    except:
        await msg.reply_text("Invalid numeric value.", quote=True)
        return

    chat_id = msg.chat.id
    if chat_id in clean_tasks:
        try:
            clean_tasks[chat_id].cancel()
        except:
            pass
    task = asyncio.create_task(clean_media_periodically(client, chat_id, seconds))
    clean_tasks[chat_id] = task
    clean_intervals[chat_id] = seconds
    await msg.reply_text(t(chat_id, "clean_custom", t=t))

@bot.on_message(filters.command(["clean_off", "cleanoff"], prefixes=["/", "!", "."]))
async def clean_off_cmd(client, msg):
    try:
        user_id = msg.from_user.id if msg.from_user else None
        if not user_id or not await is_admin_or_owner(client, msg.chat.id, user_id):
            await msg.reply_text(t(msg.chat.id, "no_permission"))
            return
    except:
        return

    chat_id = msg.chat.id
    if chat_id in clean_tasks:
        try:
            clean_tasks[chat_id].cancel()
        except:
            pass
        del clean_tasks[chat_id]
        if chat_id in clean_intervals:
            del clean_intervals[chat_id]
        await msg.reply_text(t(chat_id, "clean_off"))
    else:
        await msg.reply_text("‚ùå Auto-clean not active in this chat.")

@bot.on_message(filters.command("cleanstatus"))
async def clean_status_cmd(client, msg):
    try:
        user_id = msg.from_user.id if msg.from_user else None
        if not user_id or not await is_admin_or_owner(client, msg.chat.id, user_id):
            await msg.reply_text(t(msg.chat.id, "no_permission"))
            return
    except:
        return
    chat_id = msg.chat.id
    on = "ON" if chat_id in clean_tasks else "OFF"
    interval = clean_intervals.get(chat_id, 0)
    t = f"{interval//60}m" if interval else "‚Äî"
    await msg.reply_text(t(chat_id, "status_text", on=on, t=t))

@bot.on_message(filters.command("cleanall"))
async def cleanall_cmd(client, msg):
    try:
        user_id = msg.from_user.id if msg.from_user else None
        if not user_id or not await is_admin_or_owner(client, msg.chat.id, user_id):
            await msg.reply_text(t(msg.chat.id, "no_permission"))
            return
    except:
        return

    await msg.reply_text(t(msg.chat.id, "cleanall_start", t="24h"))
    deleted = 0
    batch = []
    cutoff = datetime.utcnow() - timedelta(hours=24)

    try:
        async for m in client.get_chat_history(msg.chat.id, limit=5000):
            if isinstance(m.date, datetime) and m.date.tzinfo is None:
                msg_date = m.date.replace(tzinfo=None)
            else:
                msg_date = m.date
            if msg_date < cutoff:
                break
            if m.media:
                batch.append(m.message_id)
                if len(batch) >= 20:
                    try:
                        await client.delete_messages(msg.chat.id, batch)
                        deleted += len(batch)
                    except Exception:
                        for mid in batch:
                            try:
                                await client.delete_messages(msg.chat.id, mid)
                                deleted += 1
                            except:
                                pass
                    batch.clear()
                    await asyncio.sleep(2)
        if batch:
            try:
                await client.delete_messages(msg.chat.id, batch)
                deleted += len(batch)
            except Exception:
                for mid in batch:
                    try:
                        await client.delete_messages(msg.chat.id, mid)
                        deleted += 1
                    except:
                        pass
    except Exception as e:
        print("cleanall error:", e)

    await msg.reply_text(t(msg.chat.id, "cleanall_done", n=deleted, t="24h"))

# --------------------------
# Media handler: NSFW always-on + schedule/delete + spam mute
# --------------------------
@bot.on_message(filters.group & (filters.photo | filters.video | filters.sticker | filters.animation | filters.document))
async def media_handler(client, message):
    if message.from_user is None:
        return

    user_id = message.from_user.id
    chat_id = message.chat.id

    tmpdir = None
    path = None
    try:
        tmpdir = tempfile.mkdtemp()
        path = await client.download_media(message, file_name=os.path.join(tmpdir, "media"))
        if not path or not os.path.exists(path):
            if path and os.path.exists(path):
                try: os.remove(path)
                except: pass
            if tmpdir:
                try: shutil.rmtree(tmpdir, ignore_errors=True)
                except: pass
            return

        nsfw_flag = is_nsfw_local(path, skin_ratio_threshold=0.30)

        try:
            if path and os.path.exists(path):
                os.remove(path)
        except:
            pass
        if tmpdir:
            try:
                shutil.rmtree(tmpdir, ignore_errors=True)
            except:
                pass

        if nsfw_flag:
            try:
                await client.delete_messages(chat_id, message.message_id)
            except:
                pass

            now = time.time()
            chat_map = user_nsfw_log.setdefault(chat_id, {})
            lst = chat_map.setdefault(user_id, [])
            lst.append(now)
            chat_map[user_id] = [t for t in lst if now - t <= 3]

            if len(chat_map[user_id]) >= 5:
                try:
                    await client.restrict_chat_member(chat_id, user_id, permissions=types.ChatPermissions(can_send_messages=False))
                    await client.send_message(chat_id, t(chat_id, "nsfw_muted"))
                    chat_map[user_id] = []
                except Exception as e:
                    print("mute failed:", e)
            else:
                try:
                    await client.send_message(chat_id, t(chat_id, "nsfw_deleted"))
                except:
                    pass
            return
        else:
            if chat_id in clean_intervals:
                interval = clean_intervals[chat_id]
                asyncio.create_task(schedule_delete(client, chat_id, message.message_id, interval))
            return
    except Exception as e:
        print("media_handler error:", e)
        try:
            if path and os.path.exists(path):
                os.remove(path)
            if tmpdir:
                shutil.rmtree(tmpdir, ignore_errors=True)
        except:
            pass

async def schedule_delete(client, chat_id, msg_id, delay):
    await asyncio.sleep(delay)
    try:
        await client.delete_messages(chat_id, msg_id)
    except:
        pass

# --------------------------
# NOTE: /nsfw_on and /nsfw_off commands intentionally removed ‚Äî NSFW always active
# --------------------------

# --------------------------
# KEEP ALIVE & WATCHDOG
# --------------------------
async def background_keepalive():
    while True:
        print("üí§ Ping: ShieldX alive...")
        await asyncio.sleep(300)

async def watchdog_task(bot_client):
    while True:
        try:
            await bot_client.send_message(OWNER_ID, "ü©µ ShieldX watchdog ping OK.", disable_notification=True)
        except Exception:
            pass
        await asyncio.sleep(1800)  # every 30 min

# --------------------------
# STARTUP
# --------------------------
async def main():
    log_module_status()
    try:
        await bot.start()
        print("‚úÖ Pyrogram client started.")
    except Exception as e:
        print("‚ùå Failed to start Pyrogram client:", e)
        return

    asyncio.create_task(background_keepalive())
    asyncio.create_task(watchdog_task(bot))
    print("ü©µ Background keepalive + watchdog running.")
    await asyncio.Event().wait()

if __name__ == "__main__":
    try:
        import nest_asyncio
        nest_asyncio.apply()
    except Exception:
        print("‚ö†Ô∏è nest_asyncio not available or failed to apply ‚Äî continuing.")

    try:
        threading.Thread(target=keep_alive_sync, daemon=True).start()
    except Exception as e:
        print("‚ö†Ô∏è Failed to start keep_alive_sync thread:", e)

    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("Shutdown requested, exiting...")
